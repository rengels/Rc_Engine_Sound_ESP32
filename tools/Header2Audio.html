<head>
<script>
"use strict";


/** Decodes a .h file and returns a buffer.
 *
 *  @returns An array with sample rate and the buffer data.
 */
function headerToArray(headerText) {

  const headerLines = headerText.split("\n");

  // -- find the sample rate:
  const srRe = /samplerate\s*=\s*(\d+)\s*;/i;
  let sampleRate = 22050;
  for (let i = 0; i < headerLines.length; i++) {
    let results = srRe.exec(headerLines[i]);
    if (results !== null) {
      sampleRate = parseInt(sampleRate)
      break;
    }
  }

  // -- find the samples (we assume it_s a line with commas
  let buffer = [];
  for (let i = 0; i < headerLines.length; i++) {
    let numbers = headerLines[i].split(",");
    if (numbers.length > 1) {
      // ignore everything after the last comma
      // might be a comment or a closing }
      for (let j = 0; j < numbers.length - 1; j++) {
          buffer.push(parseInt(numbers[j]) / 128.0);
      }
    }
  }

  return [sampleRate, buffer];
}


/** Converts the given text (header/include) file to a wav array.
 *
 *  @param repeats: The number of times the audio sample is
 *     repeated (put one after another).
 *  @returns An Int8Array with the wav data.
 */
function toWav(headerText, repeats=1) {

  const [sampleRate, buffer] = headerToArray(headerText);

  const bytesNo = 1;  // number of bytes per sample
  const channels = 1;
  const samplesNo = buffer.length * repeats;
  const fileLength = samplesNo * bytesNo + 44;
  
  const buf = new ArrayBuffer(fileLength);
  const view = new DataView(buf, 0)

  // -- RIFF section
  view.setUint8(0, "R".charCodeAt(0));
  view.setUint8(1, "I".charCodeAt(0));
  view.setUint8(2, "F".charCodeAt(0));
  view.setUint8(3, "F".charCodeAt(0));
  view.setUint32(4, fileLength - 8, true)

  // -- format section
  view.setUint8(8, "W".charCodeAt(0));
  view.setUint8(9, "A".charCodeAt(0));
  view.setUint8(10, "V".charCodeAt(0));
  view.setUint8(11, "E".charCodeAt(0));

  view.setUint8(12, "f".charCodeAt(0));
  view.setUint8(13, "m".charCodeAt(0));
  view.setUint8(14, "t".charCodeAt(0));
  view.setUint8(15, " ".charCodeAt(0));

  view.setUint32(16, 16, true); // format section length
  view.setUint16(20, 1, true);  // format type (PCM)
  view.setUint16(22, channels, true); // format type (PCM)
  view.setUint32(24, sampleRate, true);

  const bitRate = bytesNo * channels * sampleRate;
  view.setUint32(28, bitRate, true);
  view.setUint16(32, bytesNo * channels, true);
  view.setUint16(34, bytesNo * 8, true);
  
  // -- data section
  view.setUint8(36, "d".charCodeAt(0));
  view.setUint8(37, "a".charCodeAt(0));
  view.setUint8(38, "t".charCodeAt(0));
  view.setUint8(39, "a".charCodeAt(0));

  const dataSectionLength = bytesNo * samplesNo;
  view.setUint32(40, dataSectionLength, true); // data section length
  let pos = 44;
  for (let j = 0; j < repeats; j++) {
    for (let i = 0; i < buffer.length; i++) {
      if (bytesNo == 1) {
        view.setUint8(pos, Math.round(buffer[i] * (1 << 7) + (1 << 7)));
        pos++;
      } else if (bytesNo == 2) {
        view.setUint16(pos, Math.round(buffer[i] * (1 << 15)), true);
        pos+=2;
      } else if (bytesNo == 4) {
        view.setUint32(pos, Math.round(buffer[i] * (1 << 31)), true);
        pos+=4;
      }
    }
  }

  return new Uint8Array(buf);
}


/** Called when the header file is loaded.
 *
 *  Converts the input file an set's the src of the audio element,
 *  so that it be played back.
 */
function headerFileLoaded(loaded) {

  const repeats = document.querySelector('#input_repeats').value;
  const blob = new Blob(
    [toWav(loaded.target.result, repeats)],
    {type:'audio/wav'});
  const URLObject = window.webkitURL || window.URL;
  const url = URLObject.createObjectURL(blob);

  let audio_source = document.querySelector('#audio_source');
  audio_source.src = url;

  document.querySelector('#audio_download').href=url;

  let audio_control = document.querySelector('#audio_control');
  audio_control.pause();
  audio_control.load();
  audio_control.oncanplaythrough = audio_control.play();
}


/** Starts downloading and then converting the given file.
 */
function newFileSelected(event)
{
  let fr = new FileReader();
  // fr.inputFileName = event.target.files[0];
  fr.onload = headerFileLoaded;  // onload fires after reading is complete
  fr.readAsText(event.target.files[0]);
}

</script>

<style>
	body {
    font-family: arial;
	}
  legend {
    background-color: #000;
    color: #fff;
    padding: 3px 6px;
  }
  input {
    margin: 0.4rem;
  }
  fieldset {
    width: fit-content;
	  background-color: #eee;
  }
</style>

</head>

<body>
  <fieldset>
    <legend>Reverse audio converter</legend>
    <label for="input_file">Input file:</label>
    <input id="input_file" type="file" accept="*.h" onchange="newFileSelected(event)"/>
    <br />
    <label for="input_repeats">Number of repetitions:</label>
    <input id="input_repeats" type="number" min="1" max="100" value="1"/>
    <br />
    <audio id="audio_control" controls>
      <source id="audio_source" src="" type="audio/wav"/>
      <a id="audio_download" href="">Download audio</a>
    </audio>
  </fieldset>

  <small>
    Ralf Engels for <a href="https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32">ESP32 RC Engine Sound & Light Controller</a>
  </small>

</body>
</html>
