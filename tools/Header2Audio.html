<head>
<script>
"use strict";


/** Decodes a .h file and returns a buffer.
 *
 *  @returns An array with sample rate and the buffer data.
 */
function headerToArray(headerText) {

  const headerLines = headerText.split("\n");

  
  const samplerateRegex = new RegExp("samplerate\s*=\s*(\d+)\s*", "i");
  const numbersRegex = new RegExp("(?:(\d+),*)+", "g");
  var sampleRate = 22050;
  var foundSamplerate = false;
  var buffer;

  headerLines.forEach(headerLine => {
    // -- find the sample rate:
    var matches;
    if ((matches = headerLine.match(numbersRegex)) !== null){
      buffer.push(
        ...matches.map((number) => {
          return parseInt(number) / 128.0;
        })
      );
    }
    if (!foundSamplerate){
      // -- find the samples (we assume they're comma separated numbers)
      const results = samplerateRegex.exec(headerLine);
      if (results !== null){
        sampleRate = parseInt(results[0]);
        foundSamplerate = true;
      }
    }
  });
  
  return [sampleRate, buffer];
}


/** Converts the given text (header/include) file to a wav array.
 *
 *  @param repeats: The number of times the audio sample is
 *     repeated (put one after another).
 *  @returns An Int8Array with the wav data.
 */
function toWav(headerData, repeats=1) {

  const [sampleRate, buffer] = headerData;

  const bytesNo = 1;  // number of bytes per sample
  const channels = 1;
  const samplesNo = buffer.length * repeats;
  const fileLength = samplesNo * bytesNo + 44;
  
  const buf = new ArrayBuffer(fileLength);
  const view = new DataView(buf, 0)

  // -- RIFF section
  view.setUint8(0, "R".charCodeAt(0));
  view.setUint8(1, "I".charCodeAt(0));
  view.setUint8(2, "F".charCodeAt(0));
  view.setUint8(3, "F".charCodeAt(0));
  view.setUint32(4, fileLength - 8, true)

  // -- format section
  view.setUint8(8, "W".charCodeAt(0));
  view.setUint8(9, "A".charCodeAt(0));
  view.setUint8(10, "V".charCodeAt(0));
  view.setUint8(11, "E".charCodeAt(0));

  view.setUint8(12, "f".charCodeAt(0));
  view.setUint8(13, "m".charCodeAt(0));
  view.setUint8(14, "t".charCodeAt(0));
  view.setUint8(15, " ".charCodeAt(0));

  view.setUint32(16, 16, true); // format section length
  view.setUint16(20, 1, true);  // format type (PCM)
  view.setUint16(22, channels, true); // format type (PCM)
  view.setUint32(24, sampleRate, true);

  const bitRate = bytesNo * channels * sampleRate;
  view.setUint32(28, bitRate, true);
  view.setUint16(32, bytesNo * channels, true);
  view.setUint16(34, bytesNo * 8, true);
  
  // -- data section
  view.setUint8(36, "d".charCodeAt(0));
  view.setUint8(37, "a".charCodeAt(0));
  view.setUint8(38, "t".charCodeAt(0));
  view.setUint8(39, "a".charCodeAt(0));

  const dataSectionLength = bytesNo * samplesNo;
  view.setUint32(40, dataSectionLength, true); // data section length
  let pos = 44;
  for (let j = 0; j < repeats; j++) {
    for (let i = 0; i < buffer.length; i++) {
      if (bytesNo == 1) {
        view.setUint8(pos, Math.round(buffer[i] * (1 << 7) + (1 << 7)));
        pos++;
      } else if (bytesNo == 2) {
        view.setUint16(pos, Math.round(buffer[i] * (1 << 15)), true);
        pos+=2;
      } else if (bytesNo == 4) {
        view.setUint32(pos, Math.round(buffer[i] * (1 << 31)), true);
        pos+=4;
      }
    }
  }

  return new Uint8Array(buf);
}


/** Called when the header file is loaded.
 *
 *  Converts the input file an set's the src of the audio element,
 *  so that it be played back.
 */
function headerFileLoaded(loaded) {

  const repeats = document.querySelector('#input_repeats').value;
  const blob = new Blob(
    [toWav(
        headerToArray(loaded.target.result),
        repeats)],
    {type:'audio/wav'});
  const URLObject = window.webkitURL || window.URL;
  const url = URLObject.createObjectURL(blob);

  let audio_source = document.querySelector('#audio_source');
  audio_source.src = url;

  document.querySelector('#audio_download').href=url;

  let audio_control = document.querySelector('#audio_control');
  audio_control.pause();
  audio_control.load();
  audio_control.oncanplaythrough = audio_control.play();
}


/** Starts downloading and then converting the given file.
 */
function newFileSelected(event)
{
  let fr = new FileReader();
  // fr.inputFileName = event.target.files[0];
  fr.onload = headerFileLoaded;  // onload fires after reading is complete
  fr.readAsText(event.target.files[0]);
}

</script>

<style>
	body {
    font-family: arial;
	}
  legend {
    background-color: #000;
    color: #fff;
    padding: 3px 6px;
  }
  input {
    margin: 0.4rem;
  }
  fieldset {
    width: fit-content;
	  background-color: #eee;
  }
</style>

</head>

<body>
  <fieldset>
    <legend>Reverse audio converter</legend>
    <label for="input_file">Input file:</label>
    <input id="input_file" type="file" accept="*.h" onchange="newFileSelected(event)"/>
    <br />
    <label for="input_repeats">Number of repetitions:</label>
    <input id="input_repeats" type="number" min="1" max="100" value="1"/>
    <br />
    <audio id="audio_control" controls>
      <source id="audio_source" src="" type="audio/wav"/>
      <a id="audio_download" href="">Download audio</a>
    </audio>
  </fieldset>

  <small>
    Ralf Engels for <a href="https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32">ESP32 RC Engine Sound & Light Controller</a>
  </small>

</body>
</html>
